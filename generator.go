package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"regexp"
)

type Generator struct {
	bytes.Buffer
}

func (g *Generator) GenerateHead() {
	g.WriteString("// Code generated by json-constantiater DO NOT EDIT\n")
	g.WriteString("\n")
}

func (g *Generator) FormatGetString() []byte {
	src, err := format.Source(g.Bytes())
	if err != nil {
		panic(err)
	}
	return src
}

func (g *Generator) DeclarePkgNameAndImports(name string) {
	g.WriteString(fmt.Sprintf("package %s\n\n", name))
	g.WriteString("import \"github.com/sapphi-red/json-constantiater/lib\"\n\n")
}

func (g *Generator) GenerateNewJsonMarshal(n string) {
	g.WriteString(fmt.Sprintf("func (t *%s) NewJsonMarshal() []byte {\n", n))
	g.WriteString(fmt.Sprintf("res := make([]byte, 0, %d)\n", 160)) // TODO calc size
	g.WriteString("res = t.AppendJsonString(res)\n")
	g.WriteString("return res\n")
	g.WriteString("}\n\n")
}

func (g *Generator) GenerateStructAppendJsonString(n string, s *ast.StructType) {
	g.WriteString(fmt.Sprintf("func (t *%s) AppendJsonString(res []byte) []byte {\n", n))
	g.WriteString("res = append(res, '{')\n")
	for i, f := range s.Fields.List {
		g.GenerateAppendJsonStringField(f)
		if i != len(s.Fields.List) - 1 {
			g.WriteString("res = append(res, ',')\n")
		}
	}
	g.WriteString("res = append(res, '}')\n")
	g.WriteString("return res\n")
	g.WriteString("}\n\n")
}

func (g *Generator) GenerateArrayAppendJsonString(n string, s *ast.ArrayType) {
	g.WriteString(fmt.Sprintf("func (t *%s) AppendJsonString(res []byte) []byte {\n", n))
	g.WriteString("res = append(res, '[')\n")

	g.WriteString("for _, e := range *t {\n")
	g.GenerateAppendJsonStringValue("e", s.Elt, jsonTag{})
	g.WriteString("res = append(res, ',')\n")
	g.WriteString("}\n")

	g.WriteString("res = res[:len(res)-1]\n")
	g.WriteString("res = append(res, ']')\n")
	g.WriteString("return res\n")
	g.WriteString("}\n\n")
}

func (g *Generator) GenerateAppendJsonStringField(f *ast.Field) {
	if len(f.Names) > 1 {
		panic("doesnt support several names")
	}

	fieldName := f.Names[0].Name

	var j jsonTag
	if f.Tag != nil {
		j = parseJsonTag(f.Tag.Value)
	}
	if j.name == "-" {
		return
	}

	// use field name when tag name is empty
	if j.name == "" {
		j.name = ToSnakeCase(fieldName)
	}

	access := "t." + fieldName

	if j.omitempty {
		g.GenerateOmitEmptyIfNot(access, f.Type)
	}

	g.WriteString(fmt.Sprintf("res = append(res, `\"%s\":`...)\n", j.name))

	g.GenerateAppendJsonStringValue(access, f.Type, j)

	if j.omitempty {
		g.WriteString("}\n")
	}
}

func (g *Generator) GenerateAppendJsonStringValue(access string, typeExpr ast.Expr, j jsonTag) {
	typName := types.ExprString(typeExpr)
	switch typName {
	case "string":
		g.WriteString("res = append(res, '\"')\n")
		if j.noescape {
			g.WriteString(fmt.Sprintf("res = append(res, %s...)\n", access))
		} else {
			g.WriteString(fmt.Sprintf("res = lib.AppendByteWithEscape(res, %s)\n", access))
		}
		g.WriteString("res = append(res, '\"')\n")
	case "int":
		g.WriteString(fmt.Sprintf("res = lib.AppendInt(res, %s)\n", access))
	case "int8":
		g.WriteString(fmt.Sprintf("res = lib.AppendInt8(res, %s)\n", access))
	case "int16":
		g.WriteString(fmt.Sprintf("res = lib.AppendInt16(res, %s)\n", access))
	case "int32":
		g.WriteString(fmt.Sprintf("res = lib.AppendInt32(res, %s)\n", access))
	case "int64":
		g.WriteString(fmt.Sprintf("res = lib.AppendInt64(res, %s)\n", access))
	case "uint":
		g.WriteString(fmt.Sprintf("res = lib.AppendUint(res, %s)\n", access))
	case "uint8":
		g.WriteString(fmt.Sprintf("res = lib.AppendUint8(res, %s)\n", access))
	case "uint16":
		g.WriteString(fmt.Sprintf("res = lib.AppendUint16(res, %s)\n", access))
	case "uint32":
		g.WriteString(fmt.Sprintf("res = lib.AppendUint32(res, %s)\n", access))
	case "uint64":
		g.WriteString(fmt.Sprintf("res = lib.AppendUint64(res, %s)\n", access))
	default:
		g.WriteString(fmt.Sprintf("res = %s.AppendJsonString(res)\n", access))
	}
}

var intReg = regexp.MustCompile("^u?int(?:8|16|32|64)?$")

func (g *Generator) GenerateOmitEmptyIfNot(access string, typeExpr ast.Expr) {
	typName := types.ExprString(typeExpr)
	switch typName {
	case "string":
		g.WriteString(fmt.Sprintf("if %s != \"\" {\n", access))
	default:
		if intReg.MatchString(typName) {
			g.WriteString(fmt.Sprintf("if %s != 0 {\n", access))
		} else {
			panic(fmt.Sprintf("unsupported omitempty: %s", typName))
		}
	}
}
