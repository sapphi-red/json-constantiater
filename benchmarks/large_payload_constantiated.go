// Code generated by json-constantiater DO NOT EDIT

package benchmark

import "github.com/sapphi-red/json-constantiater/lib"

func (t *DSUser) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSUser) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"username\":\""...)
	res = append(res, t.Username...)
	res = append(res, "\"}"...)
	return res
}

func (t *DSTopic) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSTopic) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"id\":"...)
	if t.Id < lib.NSmalls {
		res = lib.AppendSmallInt(res, t.Id)
	} else {
		res = lib.AppendInt(res, t.Id)
	}
	res = append(res, ",\"slug\":\""...)
	res = append(res, t.Slug...)
	res = append(res, "\"}"...)
	return res
}

func (t *DSTopics) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSTopics) AppendJsonString(res []byte) []byte {
	if len(*t) <= 0 {
		return append(res, `[]`...)
	}
	res = append(res, '[')

	for _, e := range *t {
		if e == nil {
			res = append(res, `null`...)
		} else {
			res = e.AppendJsonString(res)
		}
		res = append(res, ',')
	}
	res[len(res)-1] = ']'
	return res
}

//go:nosplit
func (t *DSTopics) IsEmpty() bool {
	return len(*t) == 0
}

func (t *DSTopicsList) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSTopicsList) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"topics\":"...)
	res = t.Topics.AppendJsonString(res)
	res = append(res, ",\"more_topics_url\":\""...)
	res = append(res, t.MoreTopicsUrl...)
	res = append(res, "\"}"...)
	return res
}

func (t *DSUsers) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSUsers) AppendJsonString(res []byte) []byte {
	if len(*t) <= 0 {
		return append(res, `[]`...)
	}
	res = append(res, '[')

	for _, e := range *t {
		if e == nil {
			res = append(res, `null`...)
		} else {
			res = e.AppendJsonString(res)
		}
		res = append(res, ',')
	}
	res[len(res)-1] = ']'
	return res
}

//go:nosplit
func (t *DSUsers) IsEmpty() bool {
	return len(*t) == 0
}

func (t *LargePayload) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *LargePayload) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"users\":"...)
	res = t.Users.AppendJsonString(res)
	res = append(res, ",\"topics\":"...)
	if t.Topics == nil {
		res = append(res, `null`...)
	} else {
		res = t.Topics.AppendJsonString(res)
	}
	res = append(res, '}')
	return res
}

func (t *DSUserNonOptimized) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSUserNonOptimized) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"username\":\""...)
	res = lib.AppendByteWithEscape(res, t.Username)
	res = append(res, "\"}"...)
	return res
}

func (t *DSTopicNonOptimized) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSTopicNonOptimized) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"id\":"...)
	if 0 <= t.Id {
		if t.Id < lib.NSmalls {
			res = lib.AppendSmallInt(res, t.Id)
		} else {
			res = lib.AppendInt(res, t.Id)
		}
	} else {
		if -lib.NSmalls < t.Id {
			res = lib.AppendSmallMinusInt(res, t.Id)
		} else {
			res = lib.AppendInt(res, t.Id)
		}
	}
	res = append(res, ",\"slug\":\""...)
	res = lib.AppendByteWithEscape(res, t.Slug)
	res = append(res, "\"}"...)
	return res
}

func (t *DSTopicsNonOptimized) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSTopicsNonOptimized) AppendJsonString(res []byte) []byte {
	if len(*t) <= 0 {
		return append(res, `[]`...)
	}
	res = append(res, '[')

	for _, e := range *t {
		if e == nil {
			res = append(res, `null`...)
		} else {
			res = e.AppendJsonString(res)
		}
		res = append(res, ',')
	}
	res[len(res)-1] = ']'
	return res
}

//go:nosplit
func (t *DSTopicsNonOptimized) IsEmpty() bool {
	return len(*t) == 0
}

func (t *DSTopicsListNonOptimized) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSTopicsListNonOptimized) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"topics\":"...)
	res = t.Topics.AppendJsonString(res)
	res = append(res, ",\"more_topics_url\":\""...)
	res = lib.AppendByteWithEscape(res, t.MoreTopicsUrl)
	res = append(res, "\"}"...)
	return res
}

func (t *DSUsersNonOptimized) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *DSUsersNonOptimized) AppendJsonString(res []byte) []byte {
	if len(*t) <= 0 {
		return append(res, `[]`...)
	}
	res = append(res, '[')

	for _, e := range *t {
		if e == nil {
			res = append(res, `null`...)
		} else {
			res = e.AppendJsonString(res)
		}
		res = append(res, ',')
	}
	res[len(res)-1] = ']'
	return res
}

//go:nosplit
func (t *DSUsersNonOptimized) IsEmpty() bool {
	return len(*t) == 0
}

func (t *LargePayloadNonOptimized) NewJsonMarshal() []byte {
	tmpPtr := lib.GetFromPool()
	tmp := *tmpPtr
	tmp = t.AppendJsonString(tmp)
	res := make([]byte, len(tmp))
	copy(res, tmp)
	*tmpPtr = tmp
	lib.PutToPool(tmpPtr)
	return res
}

//go:nosplit
func (t *LargePayloadNonOptimized) AppendJsonString(res []byte) []byte {
	res = append(res, "{\"users\":"...)
	res = t.Users.AppendJsonString(res)
	res = append(res, ",\"topics\":"...)
	if t.Topics == nil {
		res = append(res, `null`...)
	} else {
		res = t.Topics.AppendJsonString(res)
	}
	res = append(res, '}')
	return res
}
